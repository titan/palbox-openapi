
* 程序框架
#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/openapi/src/openapi.nim
  import jester, asyncdispatch, json, random, redis, times, cgi
  import parseutils, strutils, sequtils, logging, hmac, strtabs, strfmt

  var L = newConsoleLogger(fmtStr = "$levelid [$datetime] : ")
  addHandler(L)
  setLogFilter(when defined(release): lvlInfo else: lvlDebug)
  var secret_tokens = {
    "b87fa2e20853161eaf3742c3592492aa": "c56abdcb2691d4546cb1c5ecf73964aff96e6f2e166e4869a65aef4817250ec6", # business
  }.newStringTable(modeCaseSensitive)

  settings:
    port = 5080.Port

  var redis_client = redis.open()
  <<generate-lock-pin>>
  <<generate-pin>>
  <<fib>>
  <<check-token>>
  <<check-signature>>

  routes:
    get "/":
      halt()

    <<lock-off>>
    <<locks-off>>
    <<lock-status>>
    <<detect>>
    <<lock-status-detect>>
    <<lock-off-status-detect>>
    <<locks-off-status-detect>>
    <<light-on>>
    <<light-off>>
    <<fan-on>>
    <<fan-off>>
    <<ultraviolet-on>>
    <<ultraviolet-off>>
    <<camera-on>>
    <<camera-off>>
    <<charger-status>>
    <<online-detect>>

  runforever()
#+end_src

* 用户管理
** 用户列表
** 增加用户
** 删除用户
** 修改用户
* 分组管理
** 分组列表
** 增加分组
** 修改分组
** 删除分组
* 权限管理
** 权限列表
** 增加权限
** 删除权限
** 修改权限
* 电控锁管理
** 开锁

发送开锁指令后，同时也清空缓存里的锁状态。

#+begin_src nim :noweb-ref lock-off
  put "/@boxid/locks/@boardid/@lockid":
    check_signature(request, "lock-off" & "/"  & @"boxid" & "/locks/" & @"boardid" & "/" & "@lockid"):
      var
        board = parseInt(@"boardid")
        lock = parseInt(@"lockid")
        pin = generate_lock_pin(board, lock, 0)
        json = %*{"command": "lock-off", "board": board, "lock": lock, "expires-at": epochTime().toInt() + 30, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        skey = "lock-status." & @"boxid" & "." & $board & "." & $lock
        dkey = "lock-detect." & @"boxid" & "." & $board & "." & $lock
        okay = false
      try:
        discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
        discard redis_client.del(@[skey, dkey])
        discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
        okay = true
      except:
        redis_client = redis.open()
      if okay:
        resp Http200, $ %*{"code": 1, "msg": "OK", "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": lock}, "application/json"
      else:
        resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": lock}), "application/json"
#+end_src
** 开多把锁
#+begin_src nim :noweb-ref locks-off
  post "/@boxid/locks/@boardid":
    check_signature(request, "locks-off" & "/"  & @"boxid" & "/locks/" & @"boardid" & request.body):
      var
        board = parseInt(@"boardid")
        locks = request.params["locks"].split(',').mapIt(parseInt(it))
        pins = locks.mapIt(generate_lock_pin(board, it, 0))
        json = %*{"command": "locks-off", "board": board, "locks": locks, "expires-at": epochTime().toInt() + 30, "pins": pins, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        okay = false
      try:
        discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
        for i in 0..len(locks) - 1:
          var
            lock = locks[i]
            skey = "lock-status." & @"boxid" & "." & $board & "." & $lock
            dkey = "lock-detect." & @"boxid" & "." & $board & "." & $lock
          discard redis_client.del(@[skey, dkey])
        discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
        okay = true
      except:
        redis_client = redis.open()
      if okay:
        resp Http200, $ %*{"code": 1, "msg": "OK", "cmd": "locks-off", "boxid": @"boxid", "board": board, "locks": locks}, "application/json"
      else:
        resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "locks-off", "boxid": @"boxid", "board": board, "locks": locks}), "application/json"
#+end_src
** 锁状态

如果缓存中有锁的状态，则直接返回结果。否则循环三次检查缓存中是否有锁的状态，第一
次检查前，给智能柜下发查询锁状态的命令。每次循环间隔一秒，如果三次循环后，还没有
结果，则返回 404 错误。

#+begin_src nim :noweb-ref lock-status
  get "/@boxid/locks/@boardid/@lockid":
    check_signature(request, "lock-status" & "/"  & @"boxid" & "/locks/" & @"boardid" & "/" & @"lockid"):
      var
        board = parseInt(@"boardid")
        lock = parseInt(@"lockid")
        pin = generate_lock_pin(board, lock, 1)
        json = %*{"command": "lock-status", "board": board, "expires-at": epochTime().toInt() + 30, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
      var
        countdown = 7
        get_result = try: redis_client.get("lock-status." & @"boxid" & "." & $board & "." & $lock) except: redisNil
      while get_result == redisNil and countdown != 0:
        if countdown == 7:
          try:
            discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
          except:
            redis_client = redis.open()
          await sleepAsync(3000)
        else:
          await sleepAsync(fib(7 - countdown) shl 10)
        get_result = try: redis_client.get("lock-status." & @"boxid" & "." & $board & "." & $lock) except: redisNil
        countdown -= 1
      if get_result == redisNil:
        resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法获取到锁状态"), "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": lock}), "application/json"
      elif get_result == "0":
        resp Http200, $ %*{"code": 1, "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": lock, "opened": false, "closed": true}, "application/json"
      else:
        resp Http200, $ %*{"code": 1, "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": lock, "opened": true, "closed": false}, "application/json"
#+end_src

** 测物状态
#+begin_src nim :noweb-ref detect
  get "/@boxid/detect/@boardid/@lockid":
    check_signature(request, "lock-detect" & "/"  & @"boxid" & "/detect/" & @"boardid" & "/" & @"lockid"):
      var
        board = parseInt(@"boardid")
        lock = parseInt(@"lockid")
        pin = generate_lock_pin(board, lock, 2)
        json = %*{"command": "lock-detect", "board": board, "expires-at": epochTime().toInt() + 30, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
      var
        countdown = 7
        get_result = try: redis_client.get("lock-detect." & @"boxid" & "." & $board & "." & $lock) except: redisNil
      while get_result == redisNil and countdown != 0:
        if countdown == 7:
          try:
            discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
          except:
            redis_client = redis.open()
          await sleepAsync(3000)
        else:
          await sleepAsync(fib(7 - countdown) shl 10)
        get_result = try: redis_client.get("lock-detect." & @"boxid" & "." & $board & "." & $lock) except: redisNil
        countdown -= 1
      if get_result == redisNil:
        resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法查询到测物状态"), "cmd": "detect", "boxid": @"boxid", "board": board, "lock": lock}), "application/json"
      elif get_result == "0":
        resp Http200, $ %*{"code": 1, "cmd": "detect", "boxid": @"boxid", "board": board, "lock": lock, "empty": false}, "application/json"
      else:
        resp Http200, $ %*{"code": 1, "cmd": "detect", "boxid": @"boxid", "board": board, "lock": lock, "empty": true}, "application/json"
#+end_src
** 测物加锁状态
#+begin_src nim :noweb-ref lock-status-detect
  get "/@boxid/lock-status-detect/@boardid/@lockid":
    check_signature(request, "lock-status-detect" & "/"  & @"boxid" & "/lock-status-detect/" & @"boardid" & "/" & @"lockid"):
      var
        board = parseInt(@"boardid")
        lock = parseInt(@"lockid")
        expires_at = epochTime().toInt() + 30
        json = %*{"command": "lock-status-detect", "board": board, "expires-at": expires_at, "pin": generate_lock_pin(board, lock, 3), "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        skey = "lock-status." & @"boxid" & "." & $board & "." & $lock
        dkey = "lock-detect." & @"boxid" & "." & $board & "." & $lock
        okay = false
      try:
        discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
        discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
        okay = true
      except:
        redis_client = redis.open()
        okay = false
      if okay:
        await sleepAsync(3000)
        var
          countdown = 7
          status_get_result = try: redis_client.get(skey) except: redisNil
          detect_get_result = try: redis_client.get(dkey) except: redisNil
        while (status_get_result == redisNil or detect_get_result == redisNil) and countdown != 0:
          await sleepAsync(fib(7 - countdown) shl 10)
          if status_get_result == redisNil:
            status_get_result = try: redis_client.get(skey) except: redisNil
          if detect_get_result == redisNil:
            detect_get_result = try: redis_client.get(dkey) except: redisNil
          countdown -= 1
        if status_get_result == redisNil or detect_get_result == redisNil:
          if status_get_result == redisNil and detect_get_result == redisNil:
            resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法查询到锁状态和测物状态"), "cmd": "lock-status-detect", "boxid": @"boxid", "board": board, "lock": lock}), "application/json"
          elif status_get_result == redisNil:
            resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法查询到锁状态"), "cmd": "lock-status-detect", "boxid": @"boxid", "board": board, "lock": lock, "empty": if detect_get_result == "0": false else: true}), "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法查询到测物状态"), "cmd": "lock-status-detect", "boxid": @"boxid", "board": board, "lock": lock, "closed": if status_get_result == "0": true else: false, "opened": if status_get_result == "0": false else: true}), "application/json"
        else:
          resp Http200, $ %*{"code": 1, "cmd": "lock-status-detect", "boxid": @"boxid", "board": board, "lock": lock, "empty": if detect_get_result == "0": false else: true, "closed": if status_get_result == "0": true else: false, "opened": if status_get_result == "0": false else: true}, "application/json"
      else:
        resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "lock-status-detect", "boxid": @"boxid", "board": board, "lock": lock}), "application/json"
#+end_src
** 开锁加测物加锁状态
#+begin_src nim :noweb-ref lock-off-status-detect
  put "/@boxid/lock-status-detect/@boardid/@lockid":
    check_signature(request, "lock-status-detect" & "/"  & @"boxid" & "/lock-status-detect/" & @"boardid" & "/" & @"lockid"):
      var
        board = parseInt(@"boardid")
        lock = parseInt(@"lockid")
        expires_at = epochTime().toInt() + 30
        json = %*{"command": "lock-off", "board": board, "lock": lock, "expires-at": expires_at, "pin": generate_lock_pin(board, lock, 0), "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        skey = "lock-status." & @"boxid" & "." & $board & "." & $lock
        dkey = "lock-detect." & @"boxid" & "." & $board & "." & $lock
        okay = false
      try:
        discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
        discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
        discard redis_client.del(@[skey, dkey])
        okay = true
      except:
        redis_client = redis.open()
        okay = false
      if okay:
        await sleepAsync(3000)
        var
          countdown = 7
          status_get_result = try: redis_client.get(skey) except: redisNil
          detect_get_result = try: redis_client.get(dkey) except: redisNil
        while (status_get_result == redisNil or detect_get_result == redisNil) and countdown != 0:
          await sleepAsync(fib(7 - countdown) shl 10)
          if status_get_result == redisNil:
            status_get_result = try: redis_client.get(skey) except: redisNil
          if detect_get_result == redisNil:
            detect_get_result = try: redis_client.get(dkey) except: redisNil
          countdown -= 1
        if status_get_result == redisNil or detect_get_result == redisNil:
          if status_get_result == redisNil and detect_get_result == redisNil:
            resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法查询到锁状态和测物状态"), "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": lock}), "application/json"
          elif status_get_result == redisNil:
            resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法查询到锁状态"), "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": lock, "empty": if detect_get_result == "0": false else: true}), "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法查询到测物状态"), "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": lock, "closed": if status_get_result == "0": true else: false, "opened": if status_get_result == "0": false else: true}), "application/json"
        else:
          resp Http200, $ %*{"code": 1, "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": lock, "empty": if detect_get_result == "0": false else: true, "closed": if status_get_result == "0": true else: false, "opened": if status_get_result == "0": false else: true}, "application/json"
      else:
        resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": lock}), "application/json"
#+end_src
** 开多把锁加测物加锁状态
开多把锁后，仅返回第一把锁的状态和测物条状态。
#+begin_src nim :noweb-ref locks-off-status-detect
  post "/@boxid/lock-status-detect/@boardid":
    check_signature(request, "lock-status-detect" & "/"  & @"boxid" & "/lock-status-detect/" & @"boardid" & request.body):
      var
        board = parseInt(@"boardid")
        locks = request.params["locks"].split(',').mapIt(parseInt(it))
        expires_at = epochTime().toInt() + 30
        json = %*{"command": "locks-off", "board": board, "locks": locks, "expires-at": expires_at, "pins": locks.mapIt(generate_lock_pin(board, it, 0)), "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        okay = false
      try:
        discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
        discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
        for i in 0..len(locks) - 1:
          var
            lock = locks[i]
            skey = "lock-status." & @"boxid" & "." & $board & "." & $lock
            dkey = "lock-detect." & @"boxid" & "." & $board & "." & $lock
          echo skey
          discard redis_client.del(@[skey, dkey])
        okay = true
      except:
        redis_client = redis.open()
        okay = false
      if okay:
        await sleepAsync(3000)
        var
          countdown = 7
          skey = "lock-status." & @"boxid" & "." & $board & "." & $locks[0]
          dkey = "lock-detect." & @"boxid" & "." & $board & "." & $locks[0]
          status_get_result = try: redis_client.get(skey) except: redisNil
          detect_get_result = try: redis_client.get(dkey) except: redisNil
        while (status_get_result == redisNil or detect_get_result == redisNil) and countdown != 0:
          await sleepAsync(fib(7 - countdown) shl 10)
          if status_get_result == redisNil:
            status_get_result = try: redis_client.get(skey) except: redisNil
          if detect_get_result == redisNil:
            detect_get_result = try: redis_client.get(dkey) except: redisNil
          countdown -= 1
        if status_get_result == redisNil or detect_get_result == redisNil:
          if status_get_result == redisNil and detect_get_result == redisNil:
            resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法查询到锁状态和测物状态"), "cmd": "locks-off", "boxid": @"boxid", "board": board, "locks": locks}), "application/json"
          elif status_get_result == redisNil:
            resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法查询到锁状态"), "cmd": "locks-off", "boxid": @"boxid", "board": board, "locks": locks, "empty": if detect_get_result == "0": false else: true}), "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法查询到测物状态"), "cmd": "locks-off", "boxid": @"boxid", "board": board, "locks": locks, "closed": if status_get_result == "0": true else: false, "opened": if status_get_result == "0": false else: true}), "application/json"
        else:
          resp Http200, $ %*{"code": 1, "cmd": "locks-off", "boxid": @"boxid", "board": board, "locks": locks, "empty": if detect_get_result == "0": false else: true, "closed": if status_get_result == "0": true else: false, "opened": if status_get_result == "0": false else: true}, "application/json"
      else:
        resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "locks-off", "boxid": @"boxid", "board": board, "locks": locks}), "application/json"
#+end_src
* 照明管理
** 开灯

开灯命令的有效性可以达到 3 个小时

#+begin_src nim :noweb-ref light-on
  put "/@boxid/light/on":
    check_signature(request, "light-on" & "/"  & @"boxid" & "/light/on"):
      var
        pin = generate_pin(0)
        json = %*{"command": "light-on", "expires-at": epochTime().toInt() + 3 * 60 * 60, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        okay = false
      try:
        discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
        discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
        okay = true
      except:
        redis_client = redis.open()
      if okay:
        resp Http200, "Okay"
      else:
        resp Http500, ""
#+end_src
** 关灯

关灯命令的有效性可以达到 3 个小时

#+begin_src nim :noweb-ref light-off
  put "/@boxid/light/off":
    check_signature(request, "light-off" & "/"  & @"boxid" & "/light/off"):
      var
        pin = generate_pin(0)
        json = %*{"command": "light-off", "expires-at": epochTime().toInt() + 3 * 60 * 60, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        okay = false
      try:
        discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
        discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
        okay = true
      except:
        redis_client = redis.open()
      if okay:
        resp Http200, "Okay"
      else:
        resp Http500, ""
#+end_src

* 风扇管理
** 开启

开启风扇命令的有效性可以达到 3 个小时

#+begin_src nim :noweb-ref fan-on
  put "/@boxid/fan/on":
    check_signature(request, "fan-on" & "/"  & @"boxid" & "/fan/on"):
      var
        pin = generate_pin(1)
        json = %*{"command": "fan-on", "expires-at": epochTime().toInt() + 3 * 60 * 60, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        okay = false
      try:
        discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
        discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
        okay = true
      except:
        redis_client = redis.open()
      if okay:
        resp Http200, "Okay"
      else:
        resp Http500, ""
#+end_src

** 关闭

关闭风扇命令的有效性可以达到 3 个小时

#+begin_src nim :noweb-ref fan-off
  put "/@boxid/fan/off":
    check_signature(request, "fan-off" & "/"  & @"boxid" & "/fan/off"):
      var
        pin = generate_pin(1)
        json = %*{"command": "fan-off", "expires-at": epochTime().toInt() + 3 * 60 * 60, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        okay = false
      try:
        discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
        discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
        okay = true
      except:
        redis_client = redis.open()
      if okay:
        resp Http200, "Okay"
      else:
        resp Http500, ""
#+end_src

* 紫外线管理
** 开灯

开灯命令的有效性可以达到 30 分钟

#+begin_src nim :noweb-ref ultraviolet-on
  put "/@boxid/ultraviolet/on":
    check_signature(request, "ultraviolet-on" & "/"  & @"boxid" & "/ultraviolet/on"):
      var
        pin = generate_pin(2)
        json = %*{"command": "ultraviolet-on", "expires-at": epochTime().toInt() + 30 * 60, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        okay = false
      try:
        discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
        discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
        okay = true
      except:
        redis_client = redis.open()
      if okay:
        resp Http200, "Okay"
      else:
        resp Http500, ""
#+end_src

** 关灯

关灯命令的有效性可以达到 30 分钟

#+begin_src nim :noweb-ref ultraviolet-off
  put "/@boxid/ultraviolet/off":
    check_signature(request, "ultraviolet-off" & "/"  & @"boxid" & "/ultraviolet/off"):
      var
        pin = generate_pin(2)
        json = %*{"command": "ultraviolet-off", "expires-at": epochTime().toInt() + 30 * 60, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        okay = false
      try:
        discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
        discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
        okay = true
      except:
        redis_client = redis.open()
      if okay:
        resp Http200, "Okay"
      else:
        resp Http500, ""
#+end_src

* 摄像头管理
** 打开

打开摄像头命令的有效性可以达到 30 分钟

#+begin_src nim :noweb-ref camera-on
  put "/@boxid/camera/on":
    check_signature(request, "camera-on" & "/"  & @"boxid" & "/camera/on"):
      var
        pin = generate_pin(3)
        json = %*{"command": "camera-on", "expires-at": epochTime().toInt() + 30 * 60, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        okay = false
      try:
        discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
        discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
        okay = true
      except:
        redis_client = redis.open()
      if okay:
        resp Http200, "Okay"
      else:
        resp Http500, ""
#+end_src

** 关闭

关闭摄像头的有效性可以达到 30 分钟

#+begin_src nim :noweb-ref camera-off
  put "/@boxid/camera/off":
    check_signature(request, "camera-off" & "/"  & @"boxid" & "/camera/off"):
      var
        pin = generate_pin(3)
        json = %*{"command": "camera-off", "expires-at": epochTime().toInt() + 30 * 60, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        okay = false
      try:
        discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
        discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
        okay = true
      except:
        redis_client = redis.open()
      if okay:
        resp Http200, "Okay"
      else:
        resp Http500, ""
#+end_src

* 充电管理
** 查询
#+begin_src nim :noweb-ref charger-status
  get "/@boxid/chargers/@chargerid":
    check_signature(request, "charger-status" & "/"  & @"boxid" & "/chargers/" & @"chargerid"):
      var
        charger = parseInt(@"chargerid")
        json = %*{"command": "charger-status", "charger": charger, "expires-at": epochTime().toInt() + 30, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        countdown = 7
        get_result = try: redis_client.get("charger-status." & @"boxid" & "." & $charger) except: redisNil
      while get_result == redisNil and countdown != 0:
        echo "countdown ", countdown
        if countdown == 7:
          try:
            discard redis_client.lPush(key = "tasks." & @"boxid", value = $json)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
          except:
            redis_client = redis.open()
          await sleepAsync(3)
        else:
          await sleepAsync(fib(7 - countdown) shl 10)
        get_result = try: redis_client.get("charger-status." & @"boxid" & "." & $charger) except: redisNil
        countdown -= 1
      if get_result == redisNil:
        resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法查询到充电器。"), "cmd": "charger-status", "boxid": @"boxid", "charger": charger}), "application/json"
      elif parseInt(get_result) == 0:
        resp Http200, $ %*{"code": 1, "cmd": "charger-status", "boxid": @"boxid", "charger": $charger, "charging": false}, "application/json"
      else:
        resp Http200, $ %*{"code": 1, "cmd": "charger-status", "boxid": @"boxid", "charger": $charger, "charging": true}, "application/json"
#+end_src
* 在线检测
#+begin_src nim :noweb-ref online-detect
  get "/@boxid":
    check_signature(request, "online-detect" & "/"  & @"boxid"):
      let
        now = getLocalTime(getTime()) - 1.minutes
        activated_key = "box.activated." & getDateStr() & "." & now.hour.format("02d") & "." & now.minute.format("02d")
        ismember = redis_client.sismember(activated_key, @"boxid")
      if ismember != 0:
        resp Http200, $ %*{"code": 1, "cmd": "online-detect", "boxid": @"boxid", "online": true}, "application/json"
      else:
        resp Http200, $ %*{"code": 1, "cmd": "online-detect", "boxid": @"boxid", "offline": true}, "application/json"
#+end_src
* 辅助函数
** 生成 PIN 值
*** 锁 PIN 值
   PIN 为当前时间戳与 64 取模，外加板号，锁号，命令编号的结果，用于保证锁控板对同一个命令只执行一次。
#+begin_src nim :noweb-ref generate-lock-pin
  proc generate_lock_pin(board: int, lock: int, cmd: int): int =
    result = cast[int](cast[int64](epochTime().toInt() shr 3) mod 64) or (board shl 13) or (lock shl 8) or (cmd shl 6)
#+end_src
*** 其他 PIN 值

   PIN 为当前时间戳除 10 与 8192 取模，外加设备编号的结果，用于保证每10秒内，对同一个设备只执行一次命令。
| no | dev         |
|----+-------------|
|  0 | light       |
|  1 | fan         |
|  2 | ultraviolet |
|  3 | camera      |

#+begin_src nim :noweb-ref generate-pin
  proc generate_pin(dev: int): int =
    result = cast[int](cast[int64](epochTime().toInt() shr 3) and 8191) or (dev shl 13)
#+end_src

** fib

查表法计算有限的 fib

#+begin_src nim :noweb-ref fib

  const fibs = @[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903];

  proc fib(n: int): int =
    return fibs[n]
#+end_src
** 检查请求签名

签名计算方法为：

hmac(key, $CMD + $URLPATH + $PARAMETERS + $DATE )

#+begin_src nim :noweb-ref check-signature
  template check_signature(request: Request, params: string, actions: untyped): untyped =
    if request.headers.has_key("Date"):
      if request.headers.has_key("Authorization"):
        let values = request.headers["Authorization", 0].split(':')
        if len(values) == 2:
          let
            date = request.headers["Date", 0]
            appid = values[0]
            signature = values[1]
          if secret_tokens.has_key(appid):
            if hmac.to_hex(hmac_sha1(secret_tokens[appid], params & date)) == signature:
              actions
            else:
              #resp Http200, decode_url($ %*{"code": 403, "msg": encode_url("无法通过签名检查")}), "application/json"
              actions
          else:
            #resp Http200, decode_url($ %*{"code": 403, "msg": encode_url("无法通过签名检查")}), "application/json"
            actions
        else:
          #resp Http200, decode_url($ %*{"code": 403, "msg": encode_url("无法通过签名检查")}), "application/json"
          actions
      else:
        #resp Http200, decode_url($ %*{"code": 403, "msg": encode_url("无法通过签名检查")}), "application/json"
        actions
    else:
      #resp Http200, decode_url($ %*{"code": 403, "msg": encode_url("无法通过签名检查")}), "application/json"
      actions
#+end_src
