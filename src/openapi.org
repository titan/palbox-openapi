#+STARTUP: indent
* 程序框架
#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/openapi/src/openapi.nim
  import jester, asyncdispatch, json, random, redis, times, cgi
  import parseutils, strutils, sequtils, logging, hmac, strtabs, strfmt
  import openapipkg/mt19937

  var L = newConsoleLogger(fmtStr = "$levelid [$datetime] : ")
  addHandler(L)
  setLogFilter(when defined(release): lvlInfo else: lvlDebug)
  var secret_tokens = {
    "b87fa2e20853161eaf3742c3592492aa": "c56abdcb2691d4546cb1c5ecf73964aff96e6f2e166e4869a65aef4817250ec6", # business
    "4b71f4fd1dec2809940abe0c558d6fc6": "d88986f75ee86951e59b49cff68244f90ae0b3e7eafdf19681b6b61f57fc7e91", # cli
  }.newStringTable(modeCaseSensitive)

  settings:
    port = 5080.Port

  <<device-constant>>
  var redis_client = redis.open()
  <<generate-lock-pin>>
  <<generate-pin>>
  <<generate-pin-1>>
  <<fib>>
  <<check-signature>>
  <<check-pin>>
  <<check-online>>
  <<loop-check-cache>>
  <<lock-status-with-locksystem>>

  routes:
    get "/":
      halt()

    <<lock-off>>
    <<locks-off>>
    <<lock-status>>
    <<lock-off-status>>
    <<locks-off-status>>
    <<light-on>>
    <<light-off>>
    <<fan-on>>
    <<fan-off>>
    <<ultraviolet-on>>
    <<ultraviolet-off>>
    <<camera-on>>
    <<camera-off>>
    <<charger-status>>
    <<charger-config>>
    <<config-charger>>
    <<online-detect>>
    <<play>>
    <<volume-up>>
    <<volume-down>>
    <<volume>>
    <<config-network>>
    <<get-token>>
    <<ping>>
    <<egg-lock-off>>
    <<egg-lock-on>>
    <<egg-play>>
    <<egg-gpio>>
    <<egg-volume>>
    <<egg-query>>
    <<rfid-reader-inventory>>
    <<rfid-reader-difference>>

  runforever()
#+end_src

* 用户管理
** 用户列表
** 增加用户
** 删除用户
** 修改用户
* 分组管理
** 分组列表
** 增加分组
** 修改分组
** 删除分组
* 权限管理
** 权限列表
** 增加权限
** 删除权限
** 修改权限
* 锁控管理
** 开锁

发送开锁指令后，同时也清空缓存里的锁状态。命令有效期 10 秒。

#+begin_src nim :noweb-ref lock-off
  put "/@boxid/locks/@boardid/@lockid":
    check_signature(request, "lock-off" & "/"  & @"boxid" & "/locks/" & @"boardid" & "/" & @"lockid"):
      check_online(@"boxid"):
        let
          board = parseInt(@"boardid")
          lock = parseInt(@"lockid")
          pin = generate_lock_pin(board, lock, 0)
          json = %*{"command": "lock-off", "board": board, "lock": lock, "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          skey = "lock-status." & @"boxid" & "." & $board & "." & $lock
          tkey = "tasks." & @"boxid"
          ackkey = "lock-off-ack." & @"boxid" & "." & $pin
          network = try: redis_client.get("network." & @"boxid") except: redisNil  # Todo: should be removed when all old box are retired
        check_pin(@"boxid", "lock-off", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.del(@[skey])
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except IOError:
            redis_client = redis.open()
          except:
            discard
          if network == "EC20":
            loop_check_cache(ackkey, cache_result):
              if cache_result != redisNil:
                resp Http200, $ %*{"code": 1, "msg": "OK", "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": lock}, "application/json"
              else:
                resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": lock}), "application/json"
          else:
            if okay:
              resp Http200, $ %*{"code": 1, "msg": "OK", "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": lock}, "application/json"
            else:
              resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": lock}), "application/json"
#+end_src
** 开多把锁
命令有效期 10 秒。
#+begin_src nim :noweb-ref locks-off
  post "/@boxid/locks/@boardid":
    check_signature(request, "locks-off" & "/"  & @"boxid" & "/locks/" & @"boardid" & request.body):
      check_online(@"boxid"):
        let
          board = parseInt(@"boardid")
          locks = request.params["locks"].split(',').mapIt(parseInt(it))
          pins = locks.mapIt(generate_lock_pin(board, it, 0))
          json = if len(pins) == 1:
                   %*{"command": "lock-off", "board": board, "lock": locks[0], "expires-at": epochTime().toInt() + 10, "pin": pins[0], "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
                 else:
                   %*{"command": "locks-off", "board": board, "locks": locks, "expires-at": epochTime().toInt() + 10, "pin": pins[0], "pins": pins, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
          ackkey = if len(pins) == 1: "lock-off-ack." & @"boxid" & "." & $pins[0] else: "locks-off-ack." & @"boxid" & "." & $pins[0]
          network = try: redis_client.get("network." & @"boxid") except: redisNil  # Todo: should be removed when all old box are retired
        check_pins(@"boxid", "locks-off", pins):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = "tasks." & @"boxid", value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            var removedkeys: seq[string] = @[]
            for i in 0..len(locks) - 1:
              var
                lock = locks[i]
                skey = "lock-status." & @"boxid" & "." & $board & "." & $lock
              removedkeys.add(skey)
            discard redis_client.del(removedkeys)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
          if len(pins) == 1:
            if network == "EC20":
              loop_check_cache(ackkey, cache_result):
                if cache_result != redisNil:
                  resp Http200, $ %*{"code": 1, "msg": "OK", "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": locks[0]}, "application/json"
                else:
                  resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": locks[0]}), "application/json"
            else:
              if okay:
                resp Http200, $ %*{"code": 1, "msg": "OK", "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": locks[0]}, "application/json"
              else:
                resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "lock-off", "boxid": @"boxid", "board": board, "lock": locks[0]}), "application/json"
          else:
            if network == "EC20":
              loop_check_cache(ackkey, cache_result):
                if cache_result != redisNil:
                  resp Http200, $ %*{"code": 1, "msg": "OK", "cmd": "locks-off", "boxid": @"boxid", "board": board, "locks": locks}, "application/json"
                else:
                  resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "locks-off", "boxid": @"boxid", "board": board, "locks": locks}), "application/json"
            else:
              if okay: # Todo: should be replaced with 'cache_result != redisNil' when all old box are retired
                resp Http200, $ %*{"code": 1, "msg": "OK", "cmd": "locks-off", "boxid": @"boxid", "board": board, "locks": locks}, "application/json"
              else:
                resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "locks-off", "boxid": @"boxid", "board": board, "locks": locks}), "application/json"
#+end_src
** 锁状态

如果缓存中有锁的状态，则直接返回结果。否则循环三次检查缓存中是否有锁的状态，第一
次检查前，给智能柜下发查询锁状态的命令。每次循环间隔一秒，如果三次循环后，还没有
结果，则返回 404 错误。命令有效期 10 秒。

#+begin_src nim :noweb-ref lock-status
  get "/@boxid/locks/@boardid/@locks":
    check_signature(request, "lock-status" & "/"  & @"boxid" & "/locks/" & @"boardid" & "/" & @"locks"):
      check_online(@"boxid"):
        let
          board = parseInt(@"boardid")
          locks = split(@"locks", ',').mapIt(parseInt(it))
          pin = generate_lock_pin(board, 0, 1)
          task = %*{"command": "lock-status", "board": board, "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "lock-status", pin):
          let
            locksystem = redis_client.get("locksystem." & @"boxid")
            resultkey = "lock-status." & @"boxid" & "." & $board & ".0"
            get_result = try: redis_client.get(resultkey) except: redisNil
          if get_result == redisNil:
            try:
              redis_client.multi()
              discard redis_client.lpush(key = tkey, value = $task)
              discard redis_client.expire(key = tkey, seconds = 86400)
              discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $task)
              discard redis_client.exec()
            except:
              redis_client = redis.open()
          loop_check_cache(resultkey, checked_result):
            if checked_result == redisNil:
              if len(locks) == 1:
                resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法获取到锁状态"), "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0]}), "application/json"
              else:
                resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "lock-status", "boxid": @"boxid", "board": board, "locks": locks}), "application/json"
            else:
              let skey = "lock-status." & @"boxid" & "." & $board
              try:
                redis_client.multi()
                discard redis_client.get(skey & ".0")
                discard redis_client.get(skey & ".1")
                discard redis_client.get(skey & ".2")
                let
                  state_strs = redis_client.exec()
                  states = state_strs.mapIt(cast[uint8](parseInt(it)))
                lock_status_with_locksystem(locksystem, states, locks, closed, opened):
                  if len(locks) == 1:
                    if len(closed) == 1:
                      resp Http200, $ %*{"code": 1, "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0], "closed": true, "opened": false, "states": state_strs}, "application/json"
                    else:
                      resp Http200, $ %*{"code": 1, "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0], "closed": false, "opened": true, "states": state_strs}, "application/json"
                  else:
                    resp Http200, $ %*{"code": 1, "cmd": "lock-status", "boxid": @"boxid", "board": board, "locks": locks, "closed": closed, "opened": opened, "states": state_strs}, "application/json"
              except IOError:
                redis_client = redis.open()
                if len(locks) == 1:
                  resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法获取到锁状态"), "exception": getCurrentExceptionMsg(), "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0]}), "application/json"
                else:
                  resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "exception": getCurrentExceptionMsg(), "cmd": "lock-status", "boxid": @"boxid", "board": board, "locks": locks}), "application/json"
              except:
                if len(locks) == 1:
                  resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法获取到锁状态"), "exception": getCurrentExceptionMsg(), "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0]}), "application/json"
                else:
                  resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "exception": getCurrentExceptionMsg(), "cmd": "lock-status", "boxid": @"boxid", "board": board, "locks": locks}), "application/json"
#+end_src

** 开锁加锁状态
命令有效期 10 秒。
#+begin_src nim :noweb-ref lock-off-status
  put "/@boxid/lock-off-and-status/@boardid/@lockid":
    check_signature(request, "lock-off-and-status" & "/"  & @"boxid" & "/lock-off-and-status/" & @"boardid" & "/" & @"lockid"):
      check_online(@"boxid"):
        let
          board = parseInt(@"boardid")
          lock = parseInt(@"lockid")
          locks = @[lock]
          expires_at = epochTime().toInt() + 10
          pin = generate_lock_pin(board, lock, 0)
          json = %*{"command": "lock-off", "board": board, "lock": lock, "expires-at": expires_at, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          statuskey = "lock-status." & @"boxid" & "." & $board & ".0"
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "lock-off", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.del(@[statuskey])
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
            okay = false
          if okay:
            loop_check_cache(statuskey, checked_result):
              if checked_result == redisNil:
                if len(locks) == 1:
                  resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法获取到锁状态"), "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0]}), "application/json"
                else:
                  resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "lock-status", "boxid": @"boxid", "board": board, "locks": locks}), "application/json"
              else:
                let locksystem = redis_client.get("locksystem." & @"boxid")
                let skey = "lock-status." & @"boxid" & "." & $board
                try:
                  redis_client.multi()
                  discard redis_client.get(skey & ".0")
                  discard redis_client.get(skey & ".1")
                  discard redis_client.get(skey & ".2")
                  let
                    state_strs = redis_client.exec()
                    states = state_strs.mapIt(cast[uint8](parseInt(it)))
                  lock_status_with_locksystem(locksystem, states, locks, closed, opened):
                    if len(locks) == 1:
                      if len(closed) == 1:
                        resp Http200, $ %*{"code": 1, "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0], "closed": true, "opened": false, "states": state_strs}, "application/json"
                      else:
                        resp Http200, $ %*{"code": 1, "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0], "closed": false, "opened": true, "states": state_strs}, "application/json"
                    else:
                      resp Http200, $ %*{"code": 1, "cmd": "lock-status", "boxid": @"boxid", "board": board, "locks": locks, "closed": closed, "opened": opened, "states": state_strs}, "application/json"
                except IOError:
                  redis_client = redis.open()
                  if len(locks) == 1:
                    resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法获取到锁状态"), "exception": getCurrentExceptionMsg(), "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0]}), "application/json"
                  else:
                    resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "exception": getCurrentExceptionMsg(), "cmd": "lock-status", "boxid": @"boxid", "board": board, "locks": locks}), "application/json"
                except:
                  if len(locks) == 1:
                    resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法获取到锁状态"), "exception": getCurrentExceptionMsg(), "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0]}), "application/json"
                  else:
                    resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "exception": getCurrentExceptionMsg(), "cmd": "lock-status", "boxid": @"boxid", "board": board, "locks": locks}), "application/json"
#+end_src
** 开多把锁加锁状态
命令有效期 10 秒。
#+begin_src nim :noweb-ref locks-off-status
  post "/@boxid/lock-off-and-status/@boardid":
    check_signature(request, "locks-off-and-status" & "/"  & @"boxid" & "/lock-off-and-status/" & @"boardid" & request.body):
      check_online(@"boxid"):
        let
          board = parseInt(@"boardid")
          locks = request.params["locks"].split(',').mapIt(parseInt(it))
          pins = locks.mapIt(generate_lock_pin(board, it, 0))
          expires_at = epochTime().toInt() + 10
          json = if len(pins) == 1:
                   %*{"command": "lock-off", "board": board, "lock": locks[0], "expires-at": expires_at, "pin": pins[0], "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
                 else:
                   %*{"command": "locks-off", "board": board, "locks": locks, "expires-at": expires_at, "pins": pins, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pins(@"boxid", "locks-off", pins):
          var okay = false
          let statuskey = "lock-status." & @"boxid" & "." & $board & ".0"
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.del(@[statuskey])
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
            okay = false
          if okay:
            loop_check_cache(statuskey, checked_result):
              if checked_result == redisNil:
                if len(locks) == 1:
                  resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法获取到锁状态"), "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0]}), "application/json"
                else:
                  resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "lock-status", "boxid": @"boxid", "board": board, "locks": locks}), "application/json"
              else:
                let locksystem = redis_client.get("locksystem." & @"boxid")
                let skey = "lock-status." & @"boxid" & "." & $board
                try:
                  redis_client.multi()
                  discard redis_client.get(skey & ".0")
                  discard redis_client.get(skey & ".1")
                  discard redis_client.get(skey & ".2")
                  let
                    state_strs = redis_client.exec()
                    states = state_strs.mapIt(cast[uint8](parseInt(it)))
                  lock_status_with_locksystem(locksystem, states, locks, closed, opened):
                    if len(locks) == 1:
                      if len(closed) == 1:
                        resp Http200, $ %*{"code": 1, "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0], "closed": true, "opened": false, "states": state_strs}, "application/json"
                      else:
                        resp Http200, $ %*{"code": 1, "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0], "closed": false, "opened": true, "states": state_strs}, "application/json"
                    else:
                      resp Http200, $ %*{"code": 1, "cmd": "lock-status", "boxid": @"boxid", "board": board, "locks": locks, "closed": closed, "opened": opened, "states": state_strs}, "application/json"
                except IOError:
                  redis_client = redis.open()
                  if len(locks) == 1:
                    resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法获取到锁状态"), "exception": getCurrentExceptionMsg(), "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0]}), "application/json"
                  else:
                    resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "exception": getCurrentExceptionMsg(), "cmd": "lock-status", "boxid": @"boxid", "board": board, "locks": locks}), "application/json"
                except:
                  if len(locks) == 1:
                    resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法获取到锁状态"), "exception": getCurrentExceptionMsg(), "cmd": "lock-status", "boxid": @"boxid", "board": board, "lock": locks[0]}), "application/json"
                  else:
                    resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "exception": getCurrentExceptionMsg(), "cmd": "lock-status", "boxid": @"boxid", "board": board, "locks": locks}), "application/json"
#+end_src
* 照明管理
** 开灯

开灯命令的有效性可以达到 10 秒

#+begin_src nim :noweb-ref light-on
  put "/@boxid/light/on":
    check_signature(request, "light-on" & "/"  & @"boxid" & "/light/on"):
      check_online(@"boxid"):
        let
          pin = generate_pin(LIGHT)
          json = %*{"command": "light-on", "qos": "<=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "light-on", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
          if okay:
            resp Http200, $ %*{"code": 1, "cmd": "light-on", "boxid": @"boxid"}, "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "light-on"}), "application/json"
#+end_src
** 关灯

关灯命令的有效性可以达到 10 秒

#+begin_src nim :noweb-ref light-off
  put "/@boxid/light/off":
    check_signature(request, "light-off" & "/"  & @"boxid" & "/light/off"):
      check_online(@"boxid"):
        let
          pin = generate_pin(LIGHT)
          json = %*{"command": "light-off", "qos": "<=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "light-off", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
          if okay:
            resp Http200, $ %*{"code": 1, "cmd": "light-off", "boxid": @"boxid"}, "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "light-off"}), "application/json"
#+end_src

* 风扇管理
** 开启

开启风扇命令的有效性可以达到 10 秒

#+begin_src nim :noweb-ref fan-on
  put "/@boxid/fan/on":
    check_signature(request, "fan-on" & "/"  & @"boxid" & "/fan/on"):
      check_online(@"boxid"):
        let
          pin = generate_pin(FAN)
          json = %*{"command": "fan-on", "qos": "<=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "fan-on", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
          if okay:
            resp Http200, $ %*{"code": 1, "cmd": "fan-on", "boxid": @"boxid"}, "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "fan-on"}), "application/json"
#+end_src

** 关闭

关闭风扇命令的有效性可以达到 10 秒

#+begin_src nim :noweb-ref fan-off
  put "/@boxid/fan/off":
    check_signature(request, "fan-off" & "/"  & @"boxid" & "/fan/off"):
      check_online(@"boxid"):
        let
          pin = generate_pin(FAN)
          json = %*{"command": "fan-off", "qos": "<=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "fan-off", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
          if okay:
            resp Http200, $ %*{"code": 1, "cmd": "fan-off", "boxid": @"boxid"}, "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "fan-off"}), "application/json"
#+end_src

* 紫外线管理
** 开灯

开灯命令的有效性可以达到 10 秒

#+begin_src nim :noweb-ref ultraviolet-on
  put "/@boxid/ultraviolet/on":
    check_signature(request, "ultraviolet-on" & "/"  & @"boxid" & "/ultraviolet/on"):
      check_online(@"boxid"):
        let
          pin = generate_pin(ULTRAVIOLET)
          json = %*{"command": "ultraviolet-on", "qos": "<=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "ultraviolet-on", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
          if okay:
            resp Http200, $ %*{"code": 1, "cmd": "ultraviolet-on", "boxid": @"boxid"}, "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "ultraviolet-on"}), "application/json"
#+end_src

** 关灯

关灯命令的有效性可以达到 10 秒

#+begin_src nim :noweb-ref ultraviolet-off
  put "/@boxid/ultraviolet/off":
    check_signature(request, "ultraviolet-off" & "/"  & @"boxid" & "/ultraviolet/off"):
      check_online(@"boxid"):
        let
          pin = generate_pin(ULTRAVIOLET)
          json = %*{"command": "ultraviolet-off", "qos": "<=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "ultraviolet-off", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
          if okay:
            resp Http200, $ %*{"code": 1, "cmd": "ultraviolet-off", "boxid": @"boxid"}, "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "ultraviolet-off"}), "application/json"
#+end_src

* 摄像头管理
** 打开

打开摄像头命令的有效性可以达到 10 秒

#+begin_src nim :noweb-ref camera-on
  put "/@boxid/camera/on":
    check_signature(request, "camera-on" & "/"  & @"boxid" & "/camera/on"):
      check_online(@"boxid"):
        let
          pin = generate_pin(CAMERA)
          json = %*{"command": "camera-on", "qos": "<=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "camera-on", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
          if okay:
            resp Http200, $ %*{"code": 1, "cmd": "camera-on", "boxid": @"boxid"}, "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "camera-on"}), "application/json"
#+end_src

** 关闭

关闭摄像头的有效性可以达到 10 秒

#+begin_src nim :noweb-ref camera-off
  put "/@boxid/camera/off":
    check_signature(request, "camera-off" & "/"  & @"boxid" & "/camera/off"):
      check_online(@"boxid"):
        let
          pin = generate_pin(CAMERA)
          json = %*{"command": "camera-off", "qos": "<=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "camera-off", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
          if okay:
            resp Http200, $ %*{"code": 1, "cmd": "camera-off", "boxid": @"boxid"}, "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "camera-off"}), "application/json"
#+end_src

* 充电管理
** 查询状态
命令有效期 10 秒。
#+begin_src nim :noweb-ref charger-status
  get "/@boxid/chargers/@chargerid":
    check_signature(request, "charger-status" & "/"  & @"boxid" & "/chargers/" & @"chargerid"):
      check_online(@"boxid"):
        let
          charger = parseInt(@"chargerid")
          pin = generate_pin(CHARGER)
          json = %*{"command": "charger-status", "charger": charger, "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
          pluggedkey = "charger-plugged." & @"boxid" & "." & $charger
          chargingkey = "charger-charging." & @"boxid" & "." & $charger
          fullkey = "charger-full." & @"boxid" & "." & $charger
          heatingkey = "charger-heating." & @"boxid" & "." & $charger
          errnokey = "charger-errno." & @"boxid" & "." & $charger
        check_pin(@"boxid", "chager-status", pin):
          var
            countdown = 7
            get_result = try: redis_client.get(pluggedkey) except: redisNil
          while get_result == redisNil and countdown != 0:
            if countdown == 7:
              try:
                redis_client.multi()
                discard redis_client.lpush(key = tkey, value = $json)
                discard redis_client.expire(key = tkey, seconds = 86400)
                discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
                discard redis_client.exec()
              except:
                redis_client = redis.open()
              await sleepAsync(3)
            else:
              await sleepAsync(fib(7 - countdown) shl 10)
            get_result = try: redis_client.get(pluggedkey) except: redisNil
            countdown -= 1
          if get_result == redisNil:
            resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法查询到充电器。"), "cmd": "charger-status", "boxid": @"boxid", "charger": charger}), "application/json"
          else:
            var
              pluggeds: seq[bool] = @[]
              chargings: seq[bool] = @[]
              fulls: seq[bool] = @[]
              heatings: seq[bool] = @[]
            try:
              redis_client.multi()
              discard redis_client.get(chargingkey)
              discard redis_client.get(fullkey)
              discard redis_client.get(heatingkey)
              discard redis_client.get(errnokey)
              var
                result_list = redis_client.exec()
                plugged = parseInt(get_result)
                charging = parseInt(result_list[0])
                full = parseInt(result_list[1])
                heating = parseInt(result_list[2])
                errno = parseInt(result_list[3])
              for i in 0..3:
                var mask = 1 shl i
                if (mask and plugged) != 0:
                  pluggeds.add(true)
                else:
                  pluggeds.add(false)
                if (mask and charging) != 0:
                  chargings.add(true)
                else:
                  chargings.add(false)
                if (mask and full) != 0:
                  fulls.add(true)
                else:
                  fulls.add(false)
                if (mask and heating) != 0:
                  heatings.add(true)
                else:
                  heatings.add(false)
              if errno == 0:
                resp Http200, $ %*{"code": 1, "cmd": "charger-status", "boxid": @"boxid", "charger": $charger, "plugged": pluggeds, "charging": chargings, "full": fulls, "heating": heatings}, "application/json"
              else:
                resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("充电器发生错误"), "boxid": @"boxid", "cmd": "charger-status", "charger": charger, "errno": errno}), "application/json"
            except:
              redis_client = redis.open()
              resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "charger-status", "charger": charger}), "application/json"
#+end_src
** 查询配置
命令有效期 10 秒。

#+begin_src nim :noweb-ref charger-config
  get "/@boxid/chargers/@chargerid/config":
    check_signature(request, "charger-config" & "/"  & @"boxid" & "/chargers/" & @"chargerid" & "/config"):
      check_online(@"boxid"):
        let
          charger = parseInt(@"chargerid")
          chargingkey = "charger-config.enable-charging." & @"boxid" & "." & $charger
          heatingkey = "charger-config.enable-heating." & @"boxid" & "." & $charger
          get_result = try: redis_client.get(chargingkey) except: redisNil
        if get_result == redisNil:
          let
            pin = generate_pin(CHARGER)
            task = %*{"command": "charger-config", "charger": charger, "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
            tkey = "tasks." & @"boxid"
          check_pin(@"boxid", "charger-config", pin):
            var
              countdown = 7
              get_result = try: redis_client.get(chargingkey) except: redisNil
            while get_result == redisNil and countdown != 0:
              if countdown == 7:
                try:
                  redis_client.multi()
                  discard redis_client.lpush(key = tkey, value = $task)
                  discard redis_client.expire(key = tkey, seconds = 86400)
                  discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $task)
                  discard redis_client.exec()
                except IOError:
                  redis_client = redis.open()
                except:
                  discard
                await sleepAsync(3)
              else:
                await sleepAsync(fib(7 - countdown) shl 10)
              get_result = try: redis_client.get(chargingkey) except: redisNil
              countdown -= 1
            if get_result == redisNil:
              resp Http200, decode_url($ %*{"code": 404, "msg": encode_url("无法获取到充电器配置"), "cmd": "charger-config", "boxid": @"boxid", "charger": charger}), "application/json"
            else:
              let
                charging_value = parseInt(get_result)
                heating_result = try: redis_client.get(heatingkey) except: redisNil
                heating_value = if heating_result != redisNil: parseInt(heating_result) else: 0
              var
                chargings: seq[bool] = @[]
                heatings: seq[bool] = @[]
              for i in 0..3:
                if (charging_value and (1 shl i)) == 0:
                  chargings.add(false)
                else:
                  chargings.add(true)
                if (heating_value and (1 shl i)) == 0:
                  heatings.add(false)
                else:
                  heatings.add(true)
              resp Http200, $ %*{"code": 1, "cmd": "charger-config", "boxid": @"boxid", "charger": charger, "enable-charging": chargings, "eanble-heating": heatings}, "application/json"
        else:
          let
            charging_value = parseInt(get_result)
            heating_result = try: redis_client.get(heatingkey) except: redisNil
            heating_value = if heating_result != redisNil: parseInt(heating_result) else: 0
          var
            chargings: seq[bool] = @[]
            heatings: seq[bool] = @[]
          for i in 0..3:
            if (charging_value and (1 shl i)) == 0:
              chargings.add(false)
            else:
              chargings.add(true)
            if (heating_value and (1 shl i)) == 0:
              heatings.add(false)
            else:
              heatings.add(true)
          resp Http200, $ %*{"code": 1, "cmd": "charger-config", "boxid": @"boxid", "charger": charger, "enable-charging": chargings, "eanble-heating": heatings}, "application/json"
#+end_src
** 修改配置
命令有效期 10 秒。

#+begin_src nim :noweb-ref config-charger
  post "/@boxid/chargers/@chargerid":
    check_signature(request, "config-charger" & "/"  & @"boxid" & "/chargers/" & @"chargerid" & request.body):
      check_online(@"boxid"):
        let
          charger = parseInt(@"chargerid")
          charging = parseInt(request.params["enable-charging"])
          heating = parseInt(request.params["enable-heating"])
          chargingkey = "charger-config.enable-charging." & @"boxid" & "." & $charger
          heatingkey = "charger-config.enable-heating." & @"boxid" & "." & $charger
          pin = generate_pin(CHARGER)
          task = %*{"command": "config-charger", "charger": charger, "enable-charging": charging, "enable-heating": heating, "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "config-charger", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = "tasks." & @"boxid", value = $task)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $task)
            discard redis_client.del(@[chargingkey, heatingkey])
            discard redis_client.exec()
            okay = true
          except IOError:
            redis_client = redis.open()
          except:
            discard
          if okay:
            resp Http200, $ %*{"code": 1, "msg": "OK", "cmd": "config-charger", "boxid": @"boxid", "charger": charger, "enable-charging": charging, "enable-heating": heating}, "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "cmd": "config-charger", "boxid": @"boxid", "charger": charger, "enable-charging": charging, "enable-heating": heating}), "application/json"
#+end_src
* 在线检测
#+begin_src nim :noweb-ref online-detect
  get "/@boxid":
    check_signature(request, "online-detect" & "/"  & @"boxid"):
      let
        now = getLocalTime(getTime())
        activated_key = "box.activated." & getDateStr() & "." & now.hour.format("02d") & "." & now.minute.format("02d")
        ismember = redis_client.sismember(activated_key, @"boxid")
      if ismember != 0:
        resp Http200, $ %*{"code": 1, "cmd": "online-detect", "boxid": @"boxid", "online": true}, "application/json"
      else:
        resp Http200, $ %*{"code": 1, "cmd": "online-detect", "boxid": @"boxid", "offline": true}, "application/json"
#+end_src
* 音频管理
speaker 的编号与 card reader 的编号一致。
** 播放
命令有效期 10 秒。
#+begin_src nim :noweb-ref play
  put "/@boxid/speakers/@speaker/audios/@audio":
    check_signature(request, "play" & "/"  & @"boxid" & "/speakers/" & @"speaker" & "/audios/" & @"audio"):
      check_online(@"boxid"):
        let
          speaker = parseInt(@"speaker")
          audio = parseInt(@"audio")
          pin = generate_lock_pin(speaker, audio, 0)
          json = %* {"command": "play", "qos": ">=1", "speaker": speaker, "audio": audio, "pin": pin, "expires-at": epochTime().toInt() + 10, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "play", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
          if okay:
            resp Http200, $ %*{"code": 1, "cmd": "play", "boxid": @"boxid", "speaker": $speaker, "audio": $audio}, "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "play", "speaker": $speaker, "audio": $audio}), "application/json"
#+end_src
** 增加音量
命令有效期 10 秒。
#+begin_src nim :noweb-ref volume-up
  put "/@boxid/speakers/@speaker/volume/up":
    check_signature(request, "volume-up" & "/"  & @"boxid" & "/speakers/" & @"speaker" & "/volume/up"):
      check_online(@"boxid"):
        let
          speaker = parseInt(@"speaker")
          pin = generate_pin_1(speaker)
          json = %* {"command": "volume-up", "qos": "<=1", "speaker": speaker, "pin": pin, "expires-at": epochTime().toInt() + 10, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "volume-up", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
          if okay:
            resp Http200, $ %*{"code": 1, "boxid": @"boxid", "cmd": "volume-up", "speaker": speaker}, "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "volume-up", "speaker": speaker}), "application/json"
#+end_src
** 减少音量
命令有效期 10 秒。
#+begin_src nim :noweb-ref volume-down
  put "/@boxid/speakers/@speaker/volume/down":
    check_signature(request, "volume-down" & "/"  & @"boxid" & "/speakers/" & @"speaker" & "/volume/down"):
      check_online(@"boxid"):
        let
          speaker = parseInt(@"speaker")
          pin = generate_pin_1(speaker)
          json = %* {"command": "volume-down", "qos": "<=1", "speaker": speaker, "pin": pin, "expires-at": epochTime().toInt() + 10, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "volume-down", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
          if okay:
            resp Http200, $ %*{"code": 1, "boxid": @"boxid", "cmd": "volume-down", "speaker": speaker}, "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "volume-down", "speaker": speaker}), "application/json"
#+end_src
** 设置音量
命令有效期 10 秒。
#+begin_src nim :noweb-ref volume
  put "/@boxid/speakers/@speaker/volume/@vol":
    check_signature(request, "volume" & "/"  & @"boxid" & "/speakers/" & @"speaker" & "/volume/" & @"vol"):
      check_online(@"boxid"):
        let
          speaker = parseInt(@"speaker")
          vol = parseInt(@"vol")
          pin = generate_pin_1(speaker)
          json = %* {"command": "volume", "qos": "<=1", "speaker": speaker, "volume": vol, "pin": pin, "expires-at": epochTime().toInt() + 10, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "volume", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
          if okay:
            resp Http200, $ %*{"code": 1, "boxid": @"boxid", "cmd": "volume", "speaker": speaker, "volume": vol}, "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "volume", "speaker": speaker, "volume": vol}), "application/json"
#+end_src
* NETWORK管理
** 配置
#+begin_src nim :noweb-ref config-network
  post "/@boxid/network":
    check_signature(request, "config-network" & "/"  & @"boxid" & "/network"):
      check_online(@"boxid"):
        let
          network_heart_rate = parseInt(request.params["network-heart-rate"])
          network_timeout = parseInt(request.params["network-timeout"])
          pin = generate_pin_1(0)
          json = %* {"command": "config-network", "pin": pin, "network-heart-rate": network_heart_rate, "network-timeout": network_timeout, "expires-at": epochTime().toInt() + 10, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
        check_pin(@"boxid", "config-network", pin):
          var okay = false
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $json)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
            discard redis_client.exec()
            okay = true
          except:
            redis_client = redis.open()
          if okay:
            resp Http200, $ %*{"code": 1, "boxid": @"boxid", "cmd": "config-network"}, "application/json"
          else:
            resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "config-network"}), "application/json"
#+end_src

* TOKEN管理
** 获取
#+begin_src nim :noweb-ref get-token
  get "/@boxid/token/@board/@locks":
    check_signature(request, "get-token" & "/"  & @"boxid" & "/token/" & @"board" & "/" & @"locks"):
      let
        board = parseInt(@"board")
        locks = split(@"locks", ',').mapIt(parseInt(it))
        boxids = @"boxid".split('-').mapIt(parseHexInt(it))
        now = epochTime().toInt()
        randkey = @[
          cast[uint32]((boxids[3] shl 24) or (boxids[2] shl 16) or (boxids[1] shl 8) or (boxids[0])),
          cast[uint32]((boxids[7] shl 24) or (boxids[6] shl 16) or (boxids[5] shl 8) or (boxids[4])),
          cast[uint32]((boxids[11] shl 24) or (boxids[10] shl 16) or (boxids[9] shl 8) or (boxids[8])),
          cast[uint32](int(now / 60))
        ]
      var
        tokens: seq[uint32] = @[]
        mt = mt19937.newMersenneTwister(randkey)
        found_token = false
        t = 0'u32
      block generating_token:
        let
          locksystem = redis_client.get("locksystem." & @"boxid")
          maxlocks = if locksystem == "FC": 24 else: 20
        if len(locks) == 2 and locks[0] + 1 == locks[1]:
          let apiversion = try: redis_client.get("api." & @"boxid") except: redisNil
          if apiversion != redisNil and apiversion != "0":
            for b in 1..8:
              for l in 1..maxlocks:
                t = mt.getNum mod 1000000'u32
            for b in 1..8:
              for l in 1..(maxlocks - 1):
                t = mt.getNum mod 1000000'u32
                if b == board:
                  if l == locks[0]:
                    tokens.insert(t, 0)
                    found_token = true
                    break generating_token
          else:
            for b in 1..8:
              for l in 1..maxlocks:
                t = mt.getNum mod 1000000'u32
                if b == board:
                  for lock in locks:
                    if l == lock:
                      tokens.insert(t, 0)
                      found_token = true
                  if len(locks) == len(tokens):
                    break generating_token
        else:
          for b in 1..8:
            for l in 1..maxlocks:
              t = mt.getNum mod 1000000'u32
              if b == board:
                for lock in locks:
                  if l == lock:
                    tokens.insert(t, 0)
                    found_token = true
                if len(locks) == len(tokens):
                  break generating_token
      if found_token:
        if len(tokens) == 1:
          if len(locks) == 1:
            resp Http200, $ %*{"code": 1, "cmd": "get-token", "boxid": @"boxid", "board": board, "lock": locks[0], "token": cast[int](tokens[0]), "timestamp": now, "randkey": randkey.mapIt(strutils.toHex(it))}, "application/json"
          else:
            resp Http200, $ %*{"code": 1, "cmd": "get-token", "boxid": @"boxid", "board": board, "locks": locks, "tokens": tokens.mapIt(cast[int](it)), "timestamp": now, "randkey": randkey.mapIt(strutils.toHex(it))}, "application/json"
        else:
          resp Http200, $ %*{"code": 1, "cmd": "get-token", "boxid": @"boxid", "board": board, "locks": locks, "tokens": tokens.mapIt(cast[int](it)), "timestamp": now, "randkey": randkey.mapIt(strutils.toHex(it))}, "application/json"
      else:
        if len(locks) == 1:
          resp Http200, $ %*{"code": 404, "cmd": "get-token", "boxid": @"boxid", "board": board, "lock": locks[0], "timestamp":now, "msg": encode_url("无法找到锁控板或锁")}
        else:
          resp Http200, $ %*{"code": 404, "cmd": "get-token", "boxid": @"boxid", "board": board, "locks": locks, "timestamp":now, "msg": encode_url("无法找到锁控板或锁")}
#+end_src
* 网络测试
#+begin_src nim :noweb-ref ping
  put "/@boxid":
    check_signature(request, "ping" & "/"  & @"boxid"):
      let
        pin = generate_pin_1(0)
        json = %*{"command": "ping", "qos":"<=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
        tkey = "tasks." & @"boxid"
      var okay = false
      try:
        redis_client.multi()
        discard redis_client.lpush(key = tkey, value = $json)
        discard redis_client.expire(key = tkey, seconds = 86400)
        discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $json)
        discard redis_client.exec()
        okay = true
      except:
        redis_client = redis.open()
      if okay:
        resp Http200, $ %*{"code": 1, "cmd": "ping", "boxid": @"boxid"}, "application/json"
      else:
        resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到缓存服务器"), "boxid": @"boxid", "cmd": "ping"}), "application/json"
#+end_src
* 扭蛋管理
** 开锁
#+begin_src nim :noweb-ref egg-lock-off
  put "/@boxid/eggs/@eggid/@cabin/off":
    check_signature(request, "egg-lock-off" & "/"  & @"boxid" & "/eggs/" & @"eggid" & "/" & @"cabin" & "/off"):
      check_online(@"boxid"):
        let
          egg = parseInt(@"eggid")
          cabin = parseInt(@"cabin")
          pin = generate_lock_pin(egg, cabin, 0)
          task = %*{"command": "egg-lock-off", "egg": egg, "cabin": cabin, "qos": ">=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
          ackkey = "egg-lock-off-ack." & @"boxid" & "." & $pin
        check_pin(@"boxid", "egg-lock-off", pin):
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $task)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $task)
            discard redis_client.exec()
          except:
            redis_client = redis.open()
          loop_check_cache(ackkey, cache_result):
            if cache_result == redisNil:
              resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到扭蛋机"), "boxid": @"boxid", "cmd": "egg-lock-off", "egg": $egg, "cabin": $cabin}), "application/json"
            else:
              resp Http200, $ %*{"code": 1, "cmd": "egg-lock-off", "boxid": @"boxid", "egg": $egg, "cabin": $cabin}, "application/json"
  post "/@boxid/eggs/@eggid/@cabin/off":
    check_signature(request, "egg-lock-off" & "/"  & @"boxid" & "/eggs/" & @"eggid" & "/" & @"cabin" & "/off"):
      check_online(@"boxid"):
        let
          egg = parseInt(@"eggid")
          cabin = parseInt(@"cabin")
          pin = generate_lock_pin(egg, cabin, 0)
          task = %*{"command": "egg-lock-off", "egg": egg, "cabin": cabin, "qos": ">=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
          ackkey = "egg-lock-off-ack." & @"boxid" & "." & $pin
        check_pin(@"boxid", "egg-lock-off", pin):
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $task)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $task)
            discard redis_client.exec()
          except:
            redis_client = redis.open()
          loop_check_cache(ackkey, cache_result):
            if cache_result == redisNil:
              resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到扭蛋机"), "boxid": @"boxid", "cmd": "egg-lock-off", "egg": $egg, "cabin": $cabin}), "application/json"
            else:
              resp Http200, $ %*{"code": 1, "cmd": "egg-lock-off", "boxid": @"boxid", "egg": $egg, "cabin": $cabin}, "application/json"
#+end_src
** 关锁
#+begin_src nim :noweb-ref egg-lock-on
  put "/@boxid/eggs/@eggid/@cabin/on":
    check_signature(request, "egg-lock-on" & "/"  & @"boxid" & "/eggs/" & @"eggid" & "/" & @"cabin" & "/on"):
      check_online(@"boxid"):
        let
          egg = parseInt(@"eggid")
          cabin = parseInt(@"cabin")
          pin = generate_lock_pin(egg, cabin, 1)
          task = %*{"command": "egg-lock-on", "egg": egg, "cabin": cabin, "qos": ">=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
          ackkey = "egg-lock-on-ack." & @"boxid" & "." & $pin
        check_pin(@"boxid", "egg-lock-on", pin):
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $task)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $task)
            discard redis_client.exec()
          except:
            redis_client = redis.open()
          loop_check_cache(ackkey, cache_result):
            if cache_result == redisNil:
              resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到扭蛋机"), "boxid": @"boxid", "cmd": "egg-lock-on", "egg": $egg, "cabin": $cabin}), "application/json"
            else:
              resp Http200, $ %*{"code": 1, "cmd": "egg-lock-on", "boxid": @"boxid", "egg": $egg, "cabin": $cabin}, "application/json"

#+end_src
** 播放
#+begin_src nim :noweb-ref egg-play
  put "/@boxid/eggs/@eggid/audios/@audio":
    check_signature(request, "egg-play" & "/"  & @"boxid" & "/eggs/" & @"eggid" & "/audios/" & @"audio"):
      check_online(@"boxid"):
        let
          egg = parseInt(@"eggid")
          audio = parseInt(@"audio")
          pin = generate_lock_pin(egg, 0, 2)
          task = %*{"command": "egg-play", "egg": egg, "audio": audio, "qos": "<=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
          ackkey = "egg-play-ack." & @"boxid" & "." & $pin
        check_pin(@"boxid", "egg-play", pin):
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $task)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $task)
            discard redis_client.exec()
          except:
            redis_client = redis.open()
          loop_check_cache(ackkey, cache_result):
            if cache_result == redisNil:
              resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到扭蛋机"), "boxid": @"boxid", "cmd": "egg-play", "egg": $egg, "audio": $audio}), "application/json"
            else:
              resp Http200, $ %*{"code": 1, "cmd": "egg-play", "boxid": @"boxid", "egg": $egg, "audio": $audio}, "application/json"

#+end_src
** GPIO 控制
#+begin_src nim :noweb-ref egg-gpio
  put "/@boxid/eggs/@eggid/gpio/@gpio":
    check_signature(request, "egg-gpio" & "/"  & @"boxid" & "/eggs/" & @"eggid" & "/gpio/" & @"gpio"):
      check_online(@"boxid"):
        let
          egg = parseInt(@"eggid")
          gpio = parseInt(@"gpio")
          pin = generate_lock_pin(egg, 0, 3)
          task = %*{"command": "egg-gpio", "egg": egg, "gpio": gpio, "qos": "<=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
          ackkey = "egg-gpio-ack." & @"boxid" & "." & $pin
        check_pin(@"boxid", "egg-gpio", pin):
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $task)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $task)
            discard redis_client.exec()
          except:
            redis_client = redis.open()
          loop_check_cache(ackkey, cache_result):
            if cache_result == redisNil:
              resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到扭蛋机"), "boxid": @"boxid", "cmd": "egg-gpio", "egg": $egg, "gpio": $gpio}), "application/json"
            else:
              resp Http200, $ %*{"code": 1, "cmd": "egg-gpio", "boxid": @"boxid", "egg": $egg, "gpio": $gpio}, "application/json"

#+end_src

** 音量调节
#+begin_src nim :noweb-ref egg-volume
  put "/@boxid/eggs/@eggid/volume/@vol":
    check_signature(request, "egg-volume" & "/"  & @"boxid" & "/eggs/" & @"eggid" & "/volume/" & @"vol"):
      check_online(@"boxid"):
        let
          egg = parseInt(@"eggid")
          vol = parseInt(@"vol")
          pin = generate_lock_pin(egg, 0, 4)
          task = %*{"command": "egg-volume", "egg": egg, "volume": vol, "qos": "<=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
          ackkey = "egg-volume-ack." & @"boxid" & "." & $pin
        check_pin(@"boxid", "egg-volume", pin):
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $task)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $task)
            discard redis_client.exec()
          except:
            redis_client = redis.open()
          loop_check_cache(ackkey, cache_result):
            if cache_result == redisNil:
              resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到扭蛋机"), "boxid": @"boxid", "cmd": "egg-volume", "egg": $egg, "volume": $vol}), "application/json"
            else:
              resp Http200, $ %*{"code": 1, "cmd": "egg-volume", "boxid": @"boxid", "egg": $egg, "volume": $vol}, "application/json"
#+end_src
** 查询状态
#+begin_src nim :noweb-ref egg-query
  get "/@boxid/eggs/@eggid/@cabin":
    check_signature(request, "egg-query" & "/"  & @"boxid" & "/eggs/" & @"eggid" & "/" & @"cabin"):
      check_online(@"boxid"):
        let
          egg = parseInt(@"eggid")
          cabin = parseInt(@"cabin")
          pin = generate_lock_pin(egg, cabin, 5)
          task = %*{"command": "egg-query", "egg": egg, "cabin": cabin, "qos": ">=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
          ackkey = "egg-busy." & @"boxid" & "." & $egg & "." & $cabin
        check_pin(@"boxid", "egg-query", pin):
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $task)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $task)
            discard redis_client.del(@[ackkey])
            discard redis_client.exec()
          except:
            redis_client = redis.open()
          loop_check_cache(ackkey, cache_result):
            if cache_result == redisNil:
              resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到扭蛋机"), "boxid": @"boxid", "cmd": "egg-query", "egg": $egg, "cabin": $cabin}), "application/json"
            else:
              resp Http200, $ %*{"code": 1, "cmd": "egg-query", "boxid": @"boxid", "egg": $egg, "cabin": $cabin, "busy": if cache_result == "1": true else: false}, "application/json"
#+end_src
* RFID管理
** 盘点
#+begin_src nim :noweb-ref rfid-reader-inventory
  put "/@boxid/rfid-readers/@board/@door/inventory":
    check_signature(request, "rfid-reader-inventory" & "/"  & @"boxid" & "/rfid-readers/" & @"board" & "/" & @"door" & "/inventory"):
      check_online(@"boxid"):
        let
          board = parseInt(@"board")
          door = parseInt(@"door")
          pin = generate_lock_pin(board, door, 1)
          task = %*{"command": "rfid-reader-inventory", "board": board, "door": door, "qos": ">=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
          ackkey = "rfid-reader-inventory-ack." & @"boxid" & "." & $pin
        check_pin(@"boxid", "rfid-reader-inventory", pin):
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $task)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $task)
            discard redis_client.exec()
          except:
            redis_client = redis.open()
          loop_check_cache(ackkey, cache_result):
            if cache_result == redisNil:
              resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到 RFID 读卡器"), "boxid": @"boxid", "cmd": "rfid-reader-inventory", "board": $board, "door": $door}), "application/json"
            else:
              resp Http200, $ %*{"code": 1, "cmd": "rfid-reader-inventory", "boxid": @"boxid", "board": $board, "door": $door}, "application/json"

#+end_src
** 求差
#+begin_src nim :noweb-ref rfid-reader-difference
  put "/@boxid/rfid-readers/@board/@door/difference":
    check_signature(request, "rfid-reader-difference" & "/"  & @"boxid" & "/rfid-readers/" & @"board" & "/" & @"door" & "/difference"):
      check_online(@"boxid"):
        let
          board = parseInt(@"board")
          door = parseInt(@"door")
          pin = generate_lock_pin(board, door, 1)
          task = %*{"command": "rfid-reader-difference", "board": board, "door": door, "qos": ">=1", "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
          tkey = "tasks." & @"boxid"
          ackkey = "rfid-reader-difference-ack." & @"boxid" & "." & $pin
        check_pin(@"boxid", "rfid-reader-difference", pin):
          try:
            redis_client.multi()
            discard redis_client.lpush(key = tkey, value = $task)
            discard redis_client.expire(key = tkey, seconds = 86400)
            discard redis_client.rpush(key = "tasklog." & @"boxid" & "." & getDateStr(), value = $task)
            discard redis_client.exec()
          except:
            redis_client = redis.open()
          loop_check_cache(ackkey, cache_result):
            if cache_result == redisNil:
              resp Http200, decode_url($ %*{"code": 500, "msg": encode_url("无法连接到 RFID 读卡器"), "boxid": @"boxid", "cmd": "rfid-reader-difference", "board": $board, "door": $door}), "application/json"
            else:
              resp Http200, $ %*{"code": 1, "cmd": "rfid-reader-difference", "boxid": @"boxid", "board": $board, "door": $door}, "application/json"

#+end_src
* MT19937
#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/openapi/src/openapipkg/mt19937.nim
  type
    MersenneTwister* = object
      mt: array[0..623, uint32]
      index: int

  {.deprecated: [TMersenneTwister: MersenneTwister].}

  proc newMersenneTwister*(seed: uint32): MersenneTwister =
    result.index = 0
    result.mt[0] = seed
    for i in 1'u32 .. 623'u32:
      result.mt[i] = (0x6c078965'u32 * (result.mt[i-1] xor (result.mt[i-1] shr 30'u32)) + i)

  proc newMersenneTwister*(seeds: seq[uint32]): MersenneTwister =
    result = newMersenneTwister(19650218'u32)
    var
      i = 1
      j = 0
      k = if 624 > len(seeds): 624 else: len(seeds)
    while k != 0:
      result.mt[i] = (result.mt[i] xor ((result.mt[i - 1] xor (result.mt[i - 1] shr 30'u32)) * 1664525'u32)) + seeds[j] + cast[uint32](j);
      #result.mt[i] = result.mt[i] and 0xFFFFFFFF'u32
      i += 1
      j += 1
      if i >= 624:
        result.mt[0] = result.mt[624 - 1]
        i = 1
      if j >= len(seeds):
        j = 0
      k -= 1
    k = 624 - 1
    while k != 0:
      result.mt[i] = (result.mt[i] xor ((result.mt[i - 1] xor (result.mt[i - 1] shr 30'u32)) * 1566083941'u32)) - cast[uint32](i)
      #result.mt[i] = result.mt[i] and 0xFFFFFFFF'u32
      i += 1
      if i >= 624:
        result.mt[0] = result.mt[624 - 1]
        i = 1
      k -= 1
    result.mt[0] = 0x80000000'u32

  proc generateNumbers(m: var MersenneTwister) =
    for i in 0..623:
      var y = (m.mt[i] and 0x80000000'u32) +
              (m.mt[(i+1) mod 624] and 0x7fffffff'u32)
      m.mt[i] = m.mt[(i+397) mod 624] xor uint32(y shr 1'u32)
      if (y mod 2'u32) != 0:
        m.mt[i] = m.mt[i] xor 0x9908b0df'u32

  proc getNum*(m: var MersenneTwister): uint32 =
    ## Returns the next pseudo random number ranging from 0 to high(uint32)
    if m.index == 0:
      generateNumbers(m)
    result = m.mt[m.index]
    m.index = (m.index + 1) mod m.mt.len

    result = result xor (result shr 11'u32)
    result = result xor ((result shl 7'u32) and 0x9d2c5680'u32)
    result = result xor ((result shl 15'u32) and 0xefc60000'u32)
    result = result xor (result shr 18'u32)

  # Test
  when not defined(testing) and isMainModule:
    var mt = newMersenneTwister(@[1'u32, 2'u32])

    for i in 0..9:
      echo mt.getNum

#+end_src
* 辅助函数
** 生成 PIN 值
*** 锁 PIN 值
   PIN 为当前时间戳与 64 取模，外加板号，锁号，命令编号的结果，用于保证锁控板对同一个命令在 4 秒内只执行一次。
#+begin_src nim :noweb-ref generate-lock-pin
  proc generate_lock_pin(board: int, lock: int, cmd: int): int =
    result = (cast[int](cast[int64](epochTime().toInt() shr 2) mod 64) or (board shl 13) or (lock shl 8) or (cmd shl 6)) and 0xFFFF
#+end_src
*** 其他 PIN 值

   PIN 为当前时间戳除 8 与 4096 取模，外加设备编号的结果，用于保证每8秒内，对同一个设备只执行一次命令。
| no | dev         |
|----+-------------|
|  1 | light       |
|  2 | fan         |
|  3 | ultraviolet |
|  4 | camera      |
|  5 | charger     |

#+begin_src nim :noweb-ref device-constant
  const
    LIGHT = 1
    FAN = 2
    ULTRAVIOLET = 3
    CAMERA = 4
    CHARGER = 5
#+end_src

#+begin_src nim :noweb-ref generate-pin
  proc generate_pin(dev: int): int =
    result = (cast[int](cast[int64](epochTime().toInt() shr 3) and 4095) or (dev shl 12)) and 0xFFFF
#+end_src

*** 秒 PIN 值

PIN 为当前时间戳

#+begin_src nim :noweb-ref generate-pin-1
  proc generate_pin_1(dev: int): int =
    result = (cast[int](epochTime().toInt() and 8191) or (dev shl 13)) and 0xFFFF
#+end_src

** fib

查表法计算有限的 fib

#+begin_src nim :noweb-ref fib

  const fibs = @[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903];

  proc fib(n: int): int =
    return fibs[n]
#+end_src
** 检查请求签名

签名计算方法为：

hmac(key, $CMD + $URLPATH + $PARAMETERS + $DATE )

#+begin_src nim :noweb-ref check-signature
  template check_signature(request: Request, params: string, actions: untyped): untyped =
    info params
    if request.headers.has_key("Date"):
      let date = request.headers["Date", 0] & ", " & request.headers["Date", 1]
      if request.headers.has_key("Authorization"):
        let values = request.headers["Authorization", 0].split(':')
        if len(values) == 2:
          let
            appid = values[0]
            signature = values[1]
          if secret_tokens.has_key(appid):
            if hmac.to_hex(hmac_sha1(secret_tokens[appid], params & date)) == signature:
              actions
            else:
              resp Http200, decode_url($ %*{"code": 403, "msg": encode_url("无法通过签名检查")}), "application/json"
              info params & date, " 请求无法通过签名检查 ", hmac.to_hex(hmac_sha1(secret_tokens[appid], params & date)), " ", signature
          else:
            resp Http200, decode_url($ %*{"code": 403, "msg": encode_url("无法通过签名检查")}), "application/json"
            info params & date, " 请求无法通过签名检查", " invalid app-key"
        else:
          resp Http200, decode_url($ %*{"code": 403, "msg": encode_url("无法通过签名检查")}), "application/json"
          info params & date, " 请求无法通过签名检查", " invalid authorization header"
      else:
        resp Http200, decode_url($ %*{"code": 403, "msg": encode_url("无法通过签名检查")}), "application/json"
        info params & date, " 请求无法通过签名检查", " no authorization header"
    else:
      resp Http200, decode_url($ %*{"code": 403, "msg": encode_url("无法通过签名检查")}), "application/json"
      info params, " 请求无法通过签名检查", " no date header"
#+end_src

** 检查 PIN 值

在缓存中检查 PIN 值是否存在。如果存在，说明该 PIN 值对应的命令已经在队
列中了，不能再入队了。如果 PIN 值不存在，则设置 PIN 值标志。缓存中的
PIN 值标志是一个对立的 KEY，命名格式为:

  pin.{boxid}.{value1[,value2]}

有效期为 10 秒，和命令的有效期保持一致。

#+begin_src nim :noweb-ref check-pin
  template check_pin(boxid: string, cmd: string, pin: int, actions: untyped): untyped =
    let
      pinkey = "pin." & boxid & "." & cmd & "." & $pin
      get_result = try: redis_client.get(pinkey) except: redisNil
    if get_result == redisNil:
      discard redis_client.setEx(pinkey, 10, "")
      actions
    else:
      resp Http200, decode_url($ %*{"code": 429, "msg": "Too many requests"}), "application/json"

  template check_pins(boxid: string, cmd: string, pins: seq[int], actions: untyped): untyped =
    let
      pinkey = "pin." & boxid & "." & cmd & "." & foldl(mapIt(pins, $it), a & "," & b)
      get_result = try: redis_client.get(pinkey) except: redisNil
    if get_result == redisNil:
      discard redis_client.setEx(pinkey, 10, "")
      actions
    else:
      resp Http200, decode_url($ %*{"code": 429, "msg": "Too many requests"}), "application/json"
#+end_src

** 检查在线状态

在缓存中检查 box 的在线状态，如果不存在，则返回 503 错误。

检查的策略如下：

1. 如果前一分钟在线，默认 box 是在线的。

2. 如果前一分钟不在线，则连续三次检查现在是否在线，然后返回结果。

#+begin_src nim :noweb-ref check-online
  template check_online(boxid: string, actions: untyped): untyped =
    let
      now = getLocalTime(getTime())
      last = now - 1.minutes
      activated_key = "box.activated." & getDateStr() & "." & now.hour.format("02d") & "." & now.minute.format("02d")
      last_activated_key = "box.activated." & getDateStr() & "." & last.hour.format("02d") & "." & last.minute.format("02d")
    var
      countdown = 3
      ismember = redis_client.sismember(last_activated_key, @"boxid")
    while ismember == 0 and countdown > 0:
      info "Check online after ", fib(4 - countdown) shl 10, " micro seconds"
      let fut = sleepAsync(fib(4 - countdown) shl 10)
      countdown -= 1
      yield fut
      ismember = redis_client.sismember(activated_key, @"boxid")
    if ismember != 0:
      actions
    else:
      resp Http200, $ %*{"code": 503, "msg": "Service Unavailable", "boxid": @"boxid"}, "application/json"
#+end_src
** 循环检查缓存结果
#+begin_src nim :noweb-ref loop-check-cache
  template loop_check_cache(key: string, check_result, actions: untyped): untyped =
    var
      countdown = 7
      check_result = redisNil
    while check_result == redisNil and countdown != 0:
      yield sleepAsync(fib(7 - countdown) shl 10)
      check_result = try: redis_client.get(key) except: redisNil
      countdown -= 1
    actions
#+end_src
** 根据锁板类型获取锁状态
#+begin_src nim :noweb-ref lock-status-with-locksystem
  template lock_status_with_locksystem(locksystem: RedisString, states: seq[uint8], locks: seq[int], closed, opened, actions: untyped): untyped =
    var
      closed: seq[int] = @[]
      opened: seq[int] = @[]
    if locksystem == "FC":
      for lock in locks:
        let idx = if lock < 9: 0 elif lock < 17: 1 else: 2
        if (states[idx] and cast[uint8](1 shl (lock - 1))) == 0:
          closed.add(lock)
        else:
          opened.add(lock)
    else:
      for lock in locks:
        let idx = if lock < 9: 2 elif lock < 17: 1 else: 0
        if (states[idx] and cast[uint8](1 shl (lock - 1))) == 0:
          opened.add(lock)
        else:
          closed.add(lock)
    actions
#+end_src
